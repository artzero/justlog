// Generated by CoffeeScript 1.4.0
var coffee, colors, cwd, justlogPath, levels, moment, path, reg, timeFormats;

coffee = require('coffee-script');

moment = require('moment');

colors = require('./colors');

path = require('path');

levels = require('./levels');

cwd = process.cwd();

reg = [/\b(file|lineno|stack|stackColored)\b/, /\b(now|time|date|fulltime|numbertime|mstimestamp|timestamp|moment)\b/, /\((.+?):(\d+):\d+\)$/];

timeFormats = {
  time: 'HH:mm:ss',
  date: 'YYYY-MM-DD',
  fulltime: 'YYYY-MM-DD HH:mm:ss',
  numbertime: 'YYYYMMDDHHmmss'
};

justlogPath = __dirname + '/justlog' + path.extname(__filename);

module.exports = {
  /*
    /**
     * pre-defined log patterns
     * @type {object}
     *  colored :
     *   - SIMPLE-COLOR: log message and colored level text
     *   - COLOR: tracestack, time, log message and colored level text
     *  nocolor :
     *   - SIMPLE-NOCOLOR:  like simple without color
     *   - NOCOLOR: like color without color
     *   - FILE : fulltime, tracestack, log message and level text
     *  connect-middleware : ()
     *   - ACCESSLOG: apache access-log
     *   - ACCESSLOG-RT: like access-log with response-time on the end (with microsecond)
  */

  pre: {
    'SIMPLE-NOCOLOR': '#{level} #{msg}',
    'SIMPLE-COLOR': '#{levelColored} #{msg}',
    'NOCOLOR': '#{time} [#{level.trim()}] (#{stack) #{msg}',
    'COLOR': '#{time} #{levelColored} #{stackColored} #{msg}',
    'FILE': '#{fulltime} [#{level.trim()}] (#{stack}) #{msg}',
    'ACCESSLOG': '#{removeAddr} #{ident} #{user}\n[#{now "DD/MMM/YYYY:HH:mm:ss ZZ"}]\n"#{method} #{url} HTTP/#{httpVersion}"\n#{statusCode} #{response.length}\n"#{headers.referer}"\n"#{headers["user-agent"]}"'.replace(/\n/g, ' '),
    'ACCESSLOG-RT': '#{removeAddr} #{ident} #{user}\n[#{now "DD/MMM/YYYY:HH:mm:ss ZZ"}]\n"#{method} #{url} HTTP/#{httpVersion}"\n#{statusCode} #{response.length}\n"#{headers.referer}"\n"#{headers["user-agent"]}"\n#{response.time}'.replace(/\n/g, ' ')
  },
  /*
    /**
     * compile log-format pattern to a render function
     * @param  {string} tpl  pattern string
     * @return {function}    pattern render function
     *  - {bool}   [trace]   need tracestack info
     *  - {bool}   [time]    need logtime info
     *  - {string} [pattern] pattern text
  */

  compile: function(pattern) {
    var code, func;
    code = coffee.compile('"' + pattern + '"', {
      bare: true
    }).trim();
    code = "with(__vars||{}){return " + code + "}";
    func = new Function('__vars', code);
    func.stack = reg[0].test(pattern);
    func.time = reg[1].test(pattern);
    func.pattern = pattern;
    return func;
  },
  /*
    /**
     * render one line
     * @param  {function} render attern render function (generate by .compile())
     * @param  {string]}  msg    log messages
     * @param  {string}   level  log level
     * @return {string}          log line text
  */

  format: function(render, msg, level) {
    var file, flag, k, now, res, stack, stacks, v, _i, _len;
    if (msg === null) {
      msg = '';
    }
    if (typeof msg !== 'object') {
      msg = {
        msg: msg.toString()
      };
    }
    msg.color = colors;
    msg.color.level = levels.color(level);
    msg.level = levels.text(level);
    msg.levelColored = "" + msg.color.level + msg.level + colors.reset;
    if (render.time) {
      now = moment();
      for (k in timeFormats) {
        v = timeFormats[k];
        msg[k] = now.format(v);
      }
      msg.now = now.format.bind(now);
      msg.mstimestamp = now.valueOf();
      msg.timestamp = Math.floor(msg.mstimestamp / 1000);
      msg.moment = moment;
    }
    if (render.stack) {
      try {
        throw new Error;
      } catch (err) {
        stacks = err.stack.split("\n");
        flag = false;
        for (_i = 0, _len = stacks.length; _i < _len; _i++) {
          stack = stacks[_i];
          if (res = stack.match(reg[2])) {
            if (res[1] !== justlogPath && res[1] !== __filename) {
              flag = true;
              break;
            }
          }
        }
        if (flag === false) {
          msg.file = 'NULL';
          msg.lineno = 0;
        } else {
          file = res[1];
          msg.file = file[0] === '/' ? path.relative(cwd, file) : file;
          msg.lineno = res[2];
        }
        msg.stack = "" + msg.file + ":" + msg.lineno;
        msg.stackColored = "" + colors.underline + colors.cyan + msg.file + ":" + colors.yellow + msg.lineno + colors.reset;
      }
    }
    return render(msg) + "\n";
  }
};
