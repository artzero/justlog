/* ****** automatically generated by jscover - do not edit ******/
if (typeof _$jscoverage === 'undefined') { _$jscoverage = {}; }
/* ****** end - do not edit ******/
function BranchData() {
    this.position = -1;
    this.nodeLength = -1;
    this.src = null;
    this.evalFalse = 0;
    this.evalTrue = 0;

    this.init = function(position, nodeLength, src) {
        this.position = position;
        this.nodeLength = nodeLength;
        this.src = src;
        return this;
    }

    this.ranCondition = function(result) {
        if (result)
            this.evalTrue++;
        else
            this.evalFalse++;
    };

    this.pathsCovered = function() {
        var paths = 0;
        if (this.evalTrue > 0)
          paths++;
        if (this.evalFalse > 0)
          paths++;
        return paths;
    };

    this.covered = function() {
        return this.evalTrue > 0 && this.evalFalse > 0;
    };

    this.toJSON = function() {
        return '{"position":' + this.position
            + ',"nodeLength":' + this.nodeLength
            + ',"src":' + jscoverage_quote(this.src)
            + ',"evalFalse":' + this.evalFalse
            + ',"evalTrue":' + this.evalTrue + '}';
    };

    this.message = function() {
        if (this.evalTrue === 0 && this.evalFalse === 0)
            return 'Condition never evaluated         :\t' + this.src;
        else if (this.evalTrue === 0)
            return 'Condition never evaluated to true :\t' + this.src;
        else if (this.evalFalse === 0)
            return 'Condition never evaluated to false:\t' + this.src;
        else
            return 'Condition covered';
    };
}

BranchData.fromJson = function(jsonString) {
    var json = eval('(' + jsonString + ')');
    var branchData = new BranchData();
    branchData.init(json.position, json.nodeLength, json.src);
    branchData.evalFalse = json.evalFalse;
    branchData.evalTrue = json.evalTrue;
    return branchData;
};

BranchData.fromJsonObject = function(json) {
    var branchData = new BranchData();
    branchData.init(json.position, json.nodeLength, json.src);
    branchData.evalFalse = json.evalFalse;
    branchData.evalTrue = json.evalTrue;
    return branchData;
};

function buildBranchMessage(conditions) {
    var message = 'The following was not covered:';
    for (var i = 0; i < conditions.length; i++) {
        if (conditions[i] !== undefined && conditions[i] !== null && !conditions[i].covered())
          message += '\n- '+ conditions[i].message();
    }
    return message;
};

function convertBranchDataConditionArrayToJSON(branchDataConditionArray) {
    var array = [];
    var length = branchDataConditionArray.length;
    for (var condition = 0; condition < length; condition++) {
        var branchDataObject = branchDataConditionArray[condition];
        if (branchDataObject === undefined || branchDataObject === null) {
            value = 'null';
        } else {
            value = branchDataObject.toJSON();
        }
        array.push(value);
    }
    return '[' + array.join(',') + ']';
}

function convertBranchDataLinesToJSON(branchData) {
    if (branchData === undefined) {
        return '[]'
    }
    var array = [];
    var length = branchData.length;
    for (var line = 0; line < length; line++) {
        var branchDataObject = branchData[line];
        if (branchDataObject === undefined || branchDataObject === null) {
            value = 'null';
        } else {
            value = convertBranchDataConditionArrayToJSON(branchDataObject);
        }
        array.push(value);
    }
    return '[' + array.join(',') + ']';
}

function convertBranchDataLinesFromJSON(jsonObject) {
    if (jsonObject === undefined) {
        return [];
    }
    var length = jsonObject.length;
    for (var line = 0; line < length; line++) {
        var branchDataJSON = jsonObject[line];
        if (branchDataJSON !== null) {
            for (var conditionIndex = 0; conditionIndex < branchDataJSON.length; conditionIndex ++) {
                var condition = branchDataJSON[conditionIndex];
                if (condition !== null) {
                    branchDataJSON[conditionIndex] = BranchData.fromJsonObject(condition);
                }
            }
        }
    }
    return jsonObject;
}
try {
  if (typeof top === 'object' && top !== null && typeof top.opener === 'object' && top.opener !== null) {
    // this is a browser window that was opened from another window

    if (! top.opener._$jscoverage) {
      top.opener._$jscoverage = {};
      top.opener._$jscoverage.branchData = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null) {
    // this is a browser window

    try {
      if (typeof top.opener === 'object' && top.opener !== null && top.opener._$jscoverage) {
        top._$jscoverage = top.opener._$jscoverage;
      }
    }
    catch (e) {}

    if (! top._$jscoverage) {
      top._$jscoverage = {};
      top._$jscoverage.branchData = {};
    }
  }
}
catch (e) {}

try {
  if (typeof top === 'object' && top !== null && top._$jscoverage) {
    this._$jscoverage = top._$jscoverage;
  }
}
catch (e) {}
if (! this._$jscoverage) {
  this._$jscoverage = {};
  this._$jscoverage.branchData = {};
}
if (! _$jscoverage['pattern.js']) {
  _$jscoverage['pattern.js'] = [];
  _$jscoverage['pattern.js'][2] = 0;
  _$jscoverage['pattern.js'][4] = 0;
  _$jscoverage['pattern.js'][6] = 0;
  _$jscoverage['pattern.js'][8] = 0;
  _$jscoverage['pattern.js'][10] = 0;
  _$jscoverage['pattern.js'][12] = 0;
  _$jscoverage['pattern.js'][14] = 0;
  _$jscoverage['pattern.js'][16] = 0;
  _$jscoverage['pattern.js'][18] = 0;
  _$jscoverage['pattern.js'][25] = 0;
  _$jscoverage['pattern.js'][27] = 0;
  _$jscoverage['pattern.js'][64] = 0;
  _$jscoverage['pattern.js'][65] = 0;
  _$jscoverage['pattern.js'][68] = 0;
  _$jscoverage['pattern.js'][69] = 0;
  _$jscoverage['pattern.js'][70] = 0;
  _$jscoverage['pattern.js'][71] = 0;
  _$jscoverage['pattern.js'][72] = 0;
  _$jscoverage['pattern.js'][73] = 0;
  _$jscoverage['pattern.js'][85] = 0;
  _$jscoverage['pattern.js'][86] = 0;
  _$jscoverage['pattern.js'][87] = 0;
  _$jscoverage['pattern.js'][89] = 0;
  _$jscoverage['pattern.js'][90] = 0;
  _$jscoverage['pattern.js'][94] = 0;
  _$jscoverage['pattern.js'][95] = 0;
  _$jscoverage['pattern.js'][96] = 0;
  _$jscoverage['pattern.js'][97] = 0;
  _$jscoverage['pattern.js'][98] = 0;
  _$jscoverage['pattern.js'][99] = 0;
  _$jscoverage['pattern.js'][100] = 0;
  _$jscoverage['pattern.js'][101] = 0;
  _$jscoverage['pattern.js'][102] = 0;
  _$jscoverage['pattern.js'][104] = 0;
  _$jscoverage['pattern.js'][105] = 0;
  _$jscoverage['pattern.js'][106] = 0;
  _$jscoverage['pattern.js'][107] = 0;
  _$jscoverage['pattern.js'][109] = 0;
  _$jscoverage['pattern.js'][110] = 0;
  _$jscoverage['pattern.js'][111] = 0;
  _$jscoverage['pattern.js'][113] = 0;
  _$jscoverage['pattern.js'][114] = 0;
  _$jscoverage['pattern.js'][115] = 0;
  _$jscoverage['pattern.js'][116] = 0;
  _$jscoverage['pattern.js'][117] = 0;
  _$jscoverage['pattern.js'][118] = 0;
  _$jscoverage['pattern.js'][119] = 0;
  _$jscoverage['pattern.js'][120] = 0;
  _$jscoverage['pattern.js'][124] = 0;
  _$jscoverage['pattern.js'][125] = 0;
  _$jscoverage['pattern.js'][126] = 0;
  _$jscoverage['pattern.js'][128] = 0;
  _$jscoverage['pattern.js'][129] = 0;
  _$jscoverage['pattern.js'][130] = 0;
  _$jscoverage['pattern.js'][132] = 0;
  _$jscoverage['pattern.js'][133] = 0;
  _$jscoverage['pattern.js'][136] = 0;
}
_$jscoverage['pattern.js'].source = ["// Generated by CoffeeScript 1.4.0","var coffee, colors, cwd, justlogPath, levels, moment, path, reg, timeFormats;","","coffee = require('coffee-script');","","moment = require('moment');","","colors = require('./colors');","","path = require('path');","","levels = require('./levels');","","cwd = process.cwd();","","reg = [/\\b(file|lineno|stack|stackColored)\\b/, /\\b(now|time|date|fulltime|numbertime|mstimestamp|timestamp|moment)\\b/, /\\((.+?):(\\d+):\\d+\\)$/];","","timeFormats = {","  time: 'HH:mm:ss',","  date: 'YYYY-MM-DD',","  fulltime: 'YYYY-MM-DD HH:mm:ss',","  numbertime: 'YYYYMMDDHHmmss'","};","","justlogPath = __dirname + '/justlog' + path.extname(__filename);","","module.exports = {","  /*","    /**","     * pre-defined log patterns","     * @type {object}","     *  colored :","     *   - SIMPLE-COLOR: log message and colored level text","     *   - COLOR: tracestack, time, log message and colored level text","     *  nocolor :","     *   - SIMPLE-NOCOLOR:  like simple without color","     *   - NOCOLOR: like color without color","     *   - FILE : fulltime, tracestack, log message and level text","     *  connect-middleware : ()","     *   - ACCESSLOG: apache access-log","     *   - ACCESSLOG-RT: like access-log with response-time on the end (with microsecond)","  */","","  pre: {","    'SIMPLE-NOCOLOR': '#{level} #{msg}',","    'SIMPLE-COLOR': '#{levelColored} #{msg}',","    'NOCOLOR': '#{time} [#{level.trim()}] (#{stack) #{msg}',","    'COLOR': '#{time} #{levelColored} #{stackColored} #{msg}',","    'FILE': '#{fulltime} [#{level.trim()}] (#{stack}) #{msg}',","    'ACCESSLOG': '#{removeAddr} #{ident} #{user}\\n[#{now \"DD/MMM/YYYY:HH:mm:ss ZZ\"}]\\n\"#{method} #{url} HTTP/#{httpVersion}\"\\n#{statusCode} #{response.length}\\n\"#{headers.referer}\"\\n\"#{headers[\"user-agent\"]}\"'.replace(/\\n/g, ' '),","    'ACCESSLOG-RT': '#{removeAddr} #{ident} #{user}\\n[#{now \"DD/MMM/YYYY:HH:mm:ss ZZ\"}]\\n\"#{method} #{url} HTTP/#{httpVersion}\"\\n#{statusCode} #{response.length}\\n\"#{headers.referer}\"\\n\"#{headers[\"user-agent\"]}\"\\n#{response.time}'.replace(/\\n/g, ' ')","  },","  /*","    /**","     * compile log-format pattern to a render function","     * @param  {string} tpl  pattern string","     * @return {function}    pattern render function","     *  - {bool}   [trace]   need tracestack info","     *  - {bool}   [time]    need logtime info","     *  - {string} [pattern] pattern text","  */","","  compile: function(pattern) {","    var code, func;","    code = coffee.compile('\"' + pattern + '\"', {","      bare: true","    }).trim();","    code = \"with(__vars||{}){return \" + code + \"}\";","    func = new Function('__vars', code);","    func.stack = reg[0].test(pattern);","    func.time = reg[1].test(pattern);","    func.pattern = pattern;","    return func;","  },","  /*","    /**","     * render one line","     * @param  {function} render attern render function (generate by .compile())","     * @param  {string]}  msg    log messages","     * @param  {string}   level  log level","     * @return {string}          log line text","  */","","  format: function(render, msg, level) {","    var file, flag, k, now, res, stack, stacks, v, _i, _len;","    if (msg === null) {","      msg = '';","    }","    if (typeof msg !== 'object') {","      msg = {","        msg: msg.toString()","      };","    }","    msg.color = colors;","    msg.color.level = levels.color(level);","    msg.level = levels.text(level);","    msg.levelColored = \"\" + msg.color.level + msg.level + colors.reset;","    if (render.time) {","      now = moment();","      for (k in timeFormats) {","        v = timeFormats[k];","        msg[k] = now.format(v);","      }","      msg.now = now.format.bind(now);","      msg.mstimestamp = now.valueOf();","      msg.timestamp = Math.floor(msg.mstimestamp / 1000);","      msg.moment = moment;","    }","    if (render.stack) {","      try {","        throw new Error;","      } catch (err) {","        stacks = err.stack.split(\"\\n\");","        flag = false;","        for (_i = 0, _len = stacks.length; _i &lt; _len; _i++) {","          stack = stacks[_i];","          if (res = stack.match(reg[2])) {","            if (res[1] !== justlogPath &amp;&amp; res[1] !== __filename) {","              flag = true;","              break;","            }","          }","        }","        if (flag === false) {","          msg.file = 'NULL';","          msg.lineno = 0;","        } else {","          file = res[1];","          msg.file = file[0] === '/' ? path.relative(cwd, file) : file;","          msg.lineno = res[2];","        }","        msg.stack = \"\" + msg.file + \":\" + msg.lineno;","        msg.stackColored = \"\" + colors.underline + colors.cyan + msg.file + \":\" + colors.yellow + msg.lineno + colors.reset;","      }","    }","    return render(msg) + \"\\n\";","  }","};"];
_$jscoverage['pattern.js'][2]++;
var coffee, colors, cwd, justlogPath, levels, moment, path, reg, timeFormats;
_$jscoverage['pattern.js'][4]++;
coffee = require('coffee-script');
_$jscoverage['pattern.js'][6]++;
moment = require('moment');
_$jscoverage['pattern.js'][8]++;
colors = require('./colors');
_$jscoverage['pattern.js'][10]++;
path = require('path');
_$jscoverage['pattern.js'][12]++;
levels = require('./levels');
_$jscoverage['pattern.js'][14]++;
cwd = process.cwd();
_$jscoverage['pattern.js'][16]++;
reg = [/\b(file|lineno|stack|stackColored)\b/, /\b(now|time|date|fulltime|numbertime|mstimestamp|timestamp|moment)\b/, /\((.+?):(\d+):\d+\)$/];
_$jscoverage['pattern.js'][18]++;
timeFormats = {
  time: 'HH:mm:ss', 
  date: 'YYYY-MM-DD', 
  fulltime: 'YYYY-MM-DD HH:mm:ss', 
  numbertime: 'YYYYMMDDHHmmss'};
_$jscoverage['pattern.js'][25]++;
justlogPath = __dirname + '/justlog' + path.extname(__filename);
_$jscoverage['pattern.js'][27]++;
module.exports = {
  pre: {
  'SIMPLE-NOCOLOR': '#{level} #{msg}', 
  'SIMPLE-COLOR': '#{levelColored} #{msg}', 
  'NOCOLOR': '#{time} [#{level.trim()}] (#{stack) #{msg}', 
  'COLOR': '#{time} #{levelColored} #{stackColored} #{msg}', 
  'FILE': '#{fulltime} [#{level.trim()}] (#{stack}) #{msg}', 
  'ACCESSLOG': '#{removeAddr} #{ident} #{user}\n[#{now "DD/MMM/YYYY:HH:mm:ss ZZ"}]\n"#{method} #{url} HTTP/#{httpVersion}"\n#{statusCode} #{response.length}\n"#{headers.referer}"\n"#{headers["user-agent"]}"'.replace(/\n/g, ' '), 
  'ACCESSLOG-RT': '#{removeAddr} #{ident} #{user}\n[#{now "DD/MMM/YYYY:HH:mm:ss ZZ"}]\n"#{method} #{url} HTTP/#{httpVersion}"\n#{statusCode} #{response.length}\n"#{headers.referer}"\n"#{headers["user-agent"]}"\n#{response.time}'.replace(/\n/g, ' ')}, 
  compile: function(pattern) {
  _$jscoverage['pattern.js'][64]++;
  var code, func;
  _$jscoverage['pattern.js'][65]++;
  code = coffee.compile('"' + pattern + '"', {
  bare: true}).trim();
  _$jscoverage['pattern.js'][68]++;
  code = "with(__vars||{}){return " + code + "}";
  _$jscoverage['pattern.js'][69]++;
  func = new Function('__vars', code);
  _$jscoverage['pattern.js'][70]++;
  func.stack = reg[0].test(pattern);
  _$jscoverage['pattern.js'][71]++;
  func.time = reg[1].test(pattern);
  _$jscoverage['pattern.js'][72]++;
  func.pattern = pattern;
  _$jscoverage['pattern.js'][73]++;
  return func;
}, 
  format: function(render, msg, level) {
  _$jscoverage['pattern.js'][85]++;
  var file, flag, k, now, res, stack, stacks, v, _i, _len;
  _$jscoverage['pattern.js'][86]++;
  if (msg === null) {
    _$jscoverage['pattern.js'][87]++;
    msg = '';
  }
  _$jscoverage['pattern.js'][89]++;
  if (typeof msg !== 'object') {
    _$jscoverage['pattern.js'][90]++;
    msg = {
  msg: msg.toString()};
  }
  _$jscoverage['pattern.js'][94]++;
  msg.color = colors;
  _$jscoverage['pattern.js'][95]++;
  msg.color.level = levels.color(level);
  _$jscoverage['pattern.js'][96]++;
  msg.level = levels.text(level);
  _$jscoverage['pattern.js'][97]++;
  msg.levelColored = "" + msg.color.level + msg.level + colors.reset;
  _$jscoverage['pattern.js'][98]++;
  if (render.time) {
    _$jscoverage['pattern.js'][99]++;
    now = moment();
    _$jscoverage['pattern.js'][100]++;
    for (k in timeFormats) {
      _$jscoverage['pattern.js'][101]++;
      v = timeFormats[k];
      _$jscoverage['pattern.js'][102]++;
      msg[k] = now.format(v);
    }
    _$jscoverage['pattern.js'][104]++;
    msg.now = now.format.bind(now);
    _$jscoverage['pattern.js'][105]++;
    msg.mstimestamp = now.valueOf();
    _$jscoverage['pattern.js'][106]++;
    msg.timestamp = Math.floor(msg.mstimestamp / 1000);
    _$jscoverage['pattern.js'][107]++;
    msg.moment = moment;
  }
  _$jscoverage['pattern.js'][109]++;
  if (render.stack) {
    _$jscoverage['pattern.js'][110]++;
    try {
      _$jscoverage['pattern.js'][111]++;
      throw new Error();
    }    catch (err) {
  _$jscoverage['pattern.js'][113]++;
  stacks = err.stack.split("\n");
  _$jscoverage['pattern.js'][114]++;
  flag = false;
  _$jscoverage['pattern.js'][115]++;
  for (_i = 0 , _len = stacks.length; _i < _len; _i++) {
    _$jscoverage['pattern.js'][116]++;
    stack = stacks[_i];
    _$jscoverage['pattern.js'][117]++;
    if (res = stack.match(reg[2])) {
      _$jscoverage['pattern.js'][118]++;
      if (res[1] !== justlogPath && res[1] !== __filename) {
        _$jscoverage['pattern.js'][119]++;
        flag = true;
        _$jscoverage['pattern.js'][120]++;
        break;
      }
    }
  }
  _$jscoverage['pattern.js'][124]++;
  if (flag === false) {
    _$jscoverage['pattern.js'][125]++;
    msg.file = 'NULL';
    _$jscoverage['pattern.js'][126]++;
    msg.lineno = 0;
  } else {
    _$jscoverage['pattern.js'][128]++;
    file = res[1];
    _$jscoverage['pattern.js'][129]++;
    msg.file = file[0] === '/' ? path.relative(cwd, file) : file;
    _$jscoverage['pattern.js'][130]++;
    msg.lineno = res[2];
  }
  _$jscoverage['pattern.js'][132]++;
  msg.stack = "" + msg.file + ":" + msg.lineno;
  _$jscoverage['pattern.js'][133]++;
  msg.stackColored = "" + colors.underline + colors.cyan + msg.file + ":" + colors.yellow + msg.lineno + colors.reset;
}
  }
  _$jscoverage['pattern.js'][136]++;
  return render(msg) + "\n";
}};
